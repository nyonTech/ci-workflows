name: CI/CD Pipeline

# This is a reusable workflow that can be called from other repositories
on:
  workflow_call:
    inputs:
      # Application Configuration
      app_name:
        description: 'Application name'
        required: true
        type: string
      
      node_version:
        description: 'Node.js version to use'
        required: false
        type: string
        default: '18'
      
      package_manager:
        description: 'Package manager to use (npm, yarn, pnpm)'
        required: false
        type: string
        default: 'npm'
      
      # Build Configuration
      build_command:
        description: 'Build command to run'
        required: false
        type: string
        default: 'build'
      
      test_command:
        description: 'Test command to run (optional)'
        required: false
        type: string
        default: ''
      
      # Deployment Configuration
      deploy_frontend:
        description: 'Deploy frontend to S3/CloudFront'
        required: false
        type: boolean
        default: true
      
      deploy_backend:
        description: 'Deploy backend to EC2'
        required: false
        type: boolean
        default: true
      
      deploy_render:
        description: 'Deploy to Render'
        required: false
        type: boolean
        default: false
      
      # Environment-specific overrides
      staging_branch:
        description: 'Branch that triggers staging deployment'
        required: false
        type: string
        default: 'develop'
      
      production_branch:
        description: 'Branch that triggers production deployment'
        required: false
        type: string
        default: 'main'
      
      # Health check configuration
      health_check_path:
        description: 'Health check endpoint path'
        required: false
        type: string
        default: '/health'
      
      backend_port_staging:
        description: 'Backend port for staging'
        required: false
        type: string
        default: '3001'
      
      backend_port_production:
        description: 'Backend port for production'
        required: false
        type: string
        default: '3000'
      
      # Custom deployment scripts
      custom_deploy_script:
        description: 'Custom deployment script path (optional)'
        required: false
        type: string
        default: ''
      
      # Notification settings
      enable_slack_notifications:
        description: 'Enable Slack notifications'
        required: false
        type: boolean
        default: true
      
      slack_channel:
        description: 'Slack channel for notifications'
        required: false
        type: string
        default: '#deployments'

    # All secrets are passed from the calling workflow
    secrets:
      # AWS Configuration
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      AWS_REGION:
        required: false
      
      # S3 & CloudFront
      STAGING_S3_BUCKET:
        required: false
      PROD_S3_BUCKET:
        required: false
      STAGING_CF_DIST_ID:
        required: false
      PROD_CF_DIST_ID:
        required: false
      
      # EC2 Configuration
      STAGING_EC2_HOST:
        required: false
      PROD_EC2_HOST:
        required: false
      EC2_USERNAME:
        required: false
      STAGING_EC2_KEY:
        required: false
      PROD_EC2_KEY:
        required: false
      
      # External Services
      RENDER_DEPLOY_HOOK:
        required: false
      SNYK_TOKEN:
        required: false
      
      # Notifications
      SLACK_WEBHOOK_URL:
        required: false
      
      # Environment URLs for testing
      STAGING_URL:
        required: false
      PROD_URL:
        required: false

env:
  NODE_VERSION: ${{ inputs.node_version }}
  PACKAGE_MANAGER: ${{ inputs.package_manager }}
  APP_NAME: ${{ inputs.app_name }}

jobs:
  # Security Scanning (optional)
  security-scan:
    if: ${{ secrets.SNYK_TOKEN != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high


  # Build and Package
  build:
    needs: [security-check]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [staging, production]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: ${{ env.PACKAGE_MANAGER }}

      - name: Install dependencies
        run: |
          if [ "${{ env.PACKAGE_MANAGER }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ env.PACKAGE_MANAGER }}" = "pnpm" ]; then
            pnpm install --frozen-lockfile
          else
            npm ci
          fi

      - name: Build application
        run: |
          if [ "${{ env.PACKAGE_MANAGER }}" = "yarn" ]; then
            yarn ${{ inputs.build_command }}:${{ matrix.environment }}
          elif [ "${{ env.PACKAGE_MANAGER }}" = "pnpm" ]; then
            pnpm ${{ inputs.build_command }}:${{ matrix.environment }}
          else
            npm run ${{ inputs.build_command }}:${{ matrix.environment }}
          fi
        env:
          NODE_ENV: ${{ matrix.environment == 'production' && 'production' || 'staging' }}
          REACT_APP_ENV: ${{ matrix.environment }}
          REACT_APP_VERSION: ${{ github.sha }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.environment }}-${{ env.APP_NAME }}
          path: build/
          retention-days: 7

  # Deploy to Staging
  deploy-staging:
    if: github.ref == format('refs/heads/{0}', inputs.staging_branch)
    needs: build
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Download build artifacts
        if: ${{ inputs.deploy_frontend }}
        uses: actions/download-artifact@v4
        with:
          name: build-staging-${{ env.APP_NAME }}
          path: build/

      - name: Configure AWS credentials
        if: ${{ inputs.deploy_frontend && secrets.AWS_ACCESS_KEY_ID != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy frontend to S3
        if: ${{ inputs.deploy_frontend && secrets.STAGING_S3_BUCKET != '' }}
        run: |
          aws s3 sync build/ s3://${{ secrets.STAGING_S3_BUCKET }} --delete --cache-control max-age=31536000,public
          aws s3 cp build/index.html s3://${{ secrets.STAGING_S3_BUCKET }}/index.html --cache-control max-age=0,no-cache,no-store,must-revalidate

      - name: Invalidate CloudFront
        if: ${{ inputs.deploy_frontend && secrets.STAGING_CF_DIST_ID != '' }}
        run: |
          aws cloudfront create-invalidation --distribution-id ${{ secrets.STAGING_CF_DIST_ID }} --paths "/*"

      - name: Deploy backend to staging
        if: ${{ inputs.deploy_backend && secrets.STAGING_EC2_HOST != '' }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.STAGING_EC2_KEY }}
          timeout: 300s
          script: |
            set -e
            cd /home/ubuntu/${{ env.APP_NAME }}
            
            # Create backup
            sudo cp -r . ../app-backup-$(date +%Y%m%d-%H%M%S)
            
            # Update code
            git fetch origin
            git checkout ${{ inputs.staging_branch }}
            git pull origin ${{ inputs.staging_branch }}
            
            # Install dependencies
            if [ "${{ env.PACKAGE_MANAGER }}" = "yarn" ]; then
              yarn install --production --frozen-lockfile
            elif [ "${{ env.PACKAGE_MANAGER }}" = "pnpm" ]; then
              pnpm install --prod --frozen-lockfile
            else
              npm ci --production
            fi
            
            # Run custom deployment script if provided
            if [ -n "${{ inputs.custom_deploy_script }}" ] && [ -f "${{ inputs.custom_deploy_script }}" ]; then
              bash ${{ inputs.custom_deploy_script }} staging
            fi
            
            # PM2 restart
            if pm2 describe ${{ env.APP_NAME }}-staging > /dev/null 2>&1; then
              pm2 reload ${{ env.APP_NAME }}-staging --wait-ready
            else
              pm2 start ecosystem.config.js --env staging
            fi
            
            # Health check
            sleep 10
            curl -f http://localhost:${{ inputs.backend_port_staging }}${{ inputs.health_check_path }} || exit 1

  # Deploy to Production
  deploy-production:
    if: github.ref == format('refs/heads/{0}', inputs.production_branch)
    needs: build
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Download build artifacts
        if: ${{ inputs.deploy_frontend }}
        uses: actions/download-artifact@v4
        with:
          name: build-production-${{ env.APP_NAME }}
          path: build/

      - name: Configure AWS credentials
        if: ${{ inputs.deploy_frontend && secrets.AWS_ACCESS_KEY_ID != '' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy frontend to S3
        if: ${{ inputs.deploy_frontend && secrets.PROD_S3_BUCKET != '' }}
        run: |
          aws s3 sync build/ s3://${{ secrets.PROD_S3_BUCKET }} --delete --cache-control max-age=31536000,public
          aws s3 cp build/index.html s3://${{ secrets.PROD_S3_BUCKET }}/index.html --cache-control max-age=0,no-cache,no-store,must-revalidate

      - name: Deploy backend to production
        if: ${{ inputs.deploy_backend && secrets.PROD_EC2_HOST != '' }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.PROD_EC2_KEY }}
          timeout: 600s
          script: |
            set -e

            # If app directory doesn't exist, set it up
            if [ ! -d "/home/ubuntu/${{ env.APP_NAME }}" ]; then
              sudo mkdir -p /home/ubuntu/${{ env.APP_NAME }}
              cd /home/ubuntu/${{ env.APP_NAME }}
              git clone -b ${{ inputs.production_branch }} ${{ secrets.REPO_URL }} .
            else
              cd /home/ubuntu/${{ env.APP_NAME }}
              git fetch origin
              git checkout ${{ inputs.production_branch }}
              git pull origin ${{ inputs.production_branch }}
            fi

            # Install dependencies
            if [ "${{ env.PACKAGE_MANAGER }}" = "yarn" ]; then
              yarn install --production --frozen-lockfile
            elif [ "${{ env.PACKAGE_MANAGER }}" = "pnpm" ]; then
              pnpm install --prod --frozen-lockfile
            else
              npm ci --production
            fi
            
            # Run custom deployment script if provided
            if [ -n "${{ inputs.custom_deploy_script }}" ] && [ -f "${{ inputs.custom_deploy_script }}" ]; then
              bash ${{ inputs.custom_deploy_script }} production
            fi
            
            # Zero-downtime deployment
            if pm2 list | grep -q "${{ env.APP_NAME }}-production"; then
              pm2 reload ${{ env.APP_NAME }}-production --wait-ready
            else
              pm2 start npm --name "${{ env.APP_NAME }}-production" -- run prod
            fi

            
            # Health check
            sleep 15
            for i in {1..5}; do
              if curl -f http://localhost:${{ inputs.backend_port_production }}${{ inputs.health_check_path }}; then
                echo "Health check passed"
                break
              elif [ $i -eq 5 ]; then
                echo "Health check failed"
                pm2 logs --lines 50
                exit 1
              else
                sleep 10
              fi
            done

      - name: Invalidate production CloudFront
        if: ${{ inputs.deploy_frontend && secrets.PROD_CF_DIST_ID != '' }}
        run: |
          aws cloudfront create-invalidation --distribution-id ${{ secrets.PROD_CF_DIST_ID }} --paths "/*"

  # Smoke Tests
  smoke-tests:
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [staging, production]
        exclude:
          - environment: staging
            if: ${{ github.ref != format('refs/heads/{0}', inputs.staging_branch) }}
          - environment: production  
            if: ${{ github.ref != format('refs/heads/{0}', inputs.production_branch) }}
    steps:
      - name: Run basic smoke test
        run: |
          if [ "${{ matrix.environment }}" = "production" ]; then
            TEST_URL="${{ secrets.PROD_URL }}"
          else
            TEST_URL="${{ secrets.STAGING_URL }}"
          fi
          
          if [ -n "$TEST_URL" ]; then
            echo "Testing $TEST_URL"
            curl -f "$TEST_URL${{ inputs.health_check_path }}" || exit 1
            echo "✅ Smoke test passed for ${{ matrix.environment }}"
          fi

  # Notifications
  notify:
    if: always() && inputs.enable_slack_notifications
    needs: [deploy-staging, deploy-production, smoke-tests]
    runs-on: ubuntu-latest
    steps:
      - name: Notify Slack on success
        if: ${{ needs.deploy-production.result == 'success' && secrets.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: ${{ inputs.slack_channel }}
          text: '✅ ${{ env.APP_NAME }} production deployment successful'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on failure
        if: ${{ failure() && secrets.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: ${{ inputs.slack_channel }}
          text: '❌ ${{ env.APP_NAME }} deployment failed'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}